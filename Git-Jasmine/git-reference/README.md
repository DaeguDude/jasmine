## 깃 튜토리얼

안녕하세요, 이번에 깃 튜토리얼을 통하여 우리는 깃을 이해하고, 가장 중요하게 깃을 어떻게 사용하는지
알아보려고 합니다. 제가 여기서 집중하고자 하는 것은, 깃이 어떻게 동작하는지 모든 것을 이해하는 것이 아니라, 여러분들이 깃을 사용할 수 있는 능력을 길러주고자 합니다. 

첫번째 수업에서는,
- 버젼관리 시스템이란?
    - 로컬 버전관리
    - 중앙집중식 버전관리
    - 분산 버전관리
- 깃이란?
- 깃 설치하기
- 깃 세팅하기

- 깃의 기초

- 리포지터리 만드는 법
    - 이미 존재하는 코드로부터 깃 레포지터리 만들기
    - 리모트 리포지터리로 부터 클론하기

- 커밋하기
- 특정 파일을 커밋에서 제외시키는 법
- 기본적인 원상복구
  - amend
    - 커밋 메세지를 잘못 입력하였을 때
    - 커밋에 파일을 추가하는 것을 까먹었을 때
    - 파일에 오타가 있을때
  - restore
    - 스테이징 공간에 잘못 추가된 파일을 다시 워킹 트리로 옮기고 싶을 때
    - 수정된 파일을 다시 원래의 상태로 돌리고 싶을 때
- 일반적인 작업흐름


## 버전관리 시스템이란?

버전관리 시스템이란 어떠한 파일들의 변화를 계속 기록하며, 어떠한 버젼을 이후에 불러낼 수 있는 시스템
입니다. 저희는 프로그래머이기 때문에 아마 코드의 변화를 기록하는데 이 시스템을 쓸 것이겠죠? 하지만 
실제로 있어, 버전관리 시스템이란 컴퓨터에 있는 모든 파일의 변화를 기록하는데 쓰일 수 있습니다.

제가 예를 들어, 그래픽 디자이너로써 버전관리 시스템을 어떻게 사용할 수 있는지 한 번 보여드리겠습니다.

<!-- <그래픽 디자이너로써의 버전관리 시스템 예시를 보여준다> -->

이렇게, 버전관리 시스템을 사용하면 아주 쉽게 파일들을 관리할 수 있습니다. 아마도 가장 적절한 버전관리 시스템의 비유는 '개쩌는' 저장버튼 이라고 봐도 무방할 것 같네요.

## 버전관리 시스템의 종류

이러한 버전관리 시스템에는 크게 3가지 종류가 있습니다. 로컬 버전 관리, 중앙집중식 버전 관리, 그리고 깃이 사용하는 분산 버전 관리가 있죠.

먼저 로컬 버전 관리시스템에 대해서 알아보겠습니다.

### 로컬 버전 관리 시스템(Local Version Control Systems)

많은 사람들이 파일을 관리할 때, 보통 파일을 복사해서 다른 폴더에 놔두고는 하죠. 이것이 아주 편하기는 하지만, 실수를 할 확률이 아주 많습니다. 어디에 파일을 복사해 두었는지 잊을 수도 있고, 파일을 지워버릴 수도 있어요. 그래서 이런 이슈를 해결하기 위해서 프로그래머들이 로컬 버전 관리시스템이라는 것을 개발했습니다. 로컬 버전관리는 아주 간단한 데이터베이스를 컴퓨터에 만들어 거기에 파일의 변화를 관리하는 시스템입니다.

<!-- 로컬 버전 관리 시스템 이미지 -->

이런 식으로 버전이 컴퓨터에 저장되어 있으면, 저희가 원하는 버전을 불러와서 사용하는 방식이죠. 이것만큼으로도 사실 아주 좋습니다. 하지만, 이렇게 로컬 버전 관리를 사용하다 보면 문제가 한 가지 생기죠. 무엇이라고 생각하십니까?

### 중앙집중식 버전 관리(Centralized Version Control Systems)

로컬 버전 관리를 사용하다 보면 문제가 한 가지 생깁니다. 사람들이랑 협력을 해야할 때 아주 제한적입니다. 그래서 생겨난 것이 중앙집중식 버전 관리 시스템이라는 것인데요. 이것이 동작하는 방식은, 한 개의 서버가 있고, 그 서버에서 모든 파일의 버전을 관리하며 클라이언트(유저 혹은 개발자)쪽에서 그 서버에 접근하여 파일을 얻는 방식입니다. 

이미지를 보면 이런식으로 되겠죠.

<!-- 중앙집중식 버전 관리 시스템 이미지 -->

이 방법이 오랫동안 거의 메인으로 자리 잡았습니다. 하지만 이 방법에도 아주 제한적인 부분이 하나 있습니다. 가장 명확한 것은, 서버가 다운되었을 때의 상황입니다. 만약에 서버가 몇 시간 동안 다운이 된다면 사람들이 일을 할 수 없겠죠? 또 만약 서버가 사고로 날라간다면, 백업이 없기 때문에 파일에 들인 모든 노력들이 한 순간에 날아갈 수 있습니다. 로컬 버전 관리 시스템들도 이러한 제한적인 부분이 있는 것은 마찬가지입니다.

### 분산 버전 관리 시스템(Distributed Version Control Systems)

이러한 문제들을 다 해결하기 위해서 생겨난 것이 분산 버전 관리 시스템입니다. 깃이 대표적인 분산 버전 관리 시스템이죠. 분산 버전 관리 시스템은, 파일의 마지막 버전만 가져오는 것이 아니라, 그 파일의 모든 버전을 가져옵니다. 이것이 왜 안전하냐면, 여러 명이 그 프로젝트에 참여하고 있다고 할 때, 모두가 파일의 백업을 가지고 있는 상황이 되는 것입니다. 예를 들어서, 여러 명이 같이 협력하고 있는 서버가 죽거나 날라갔다고 생각했을 때, 모두가 백업을 가지고 있어 아주 안전하죠. 

게다가 분산 버전 관리 시스템들은 여러 개의 클라이언트 저장소를 가지는 것을 허용하기 때문에, 많은 사람들이 한 프로젝트에서 다양한 방향으로 일을 해나갈 수 있습니다.

예를 들어, 계산기를 만들고 있다고 생각해봅시다. 간단한 디자인 파트는 끝이났고 이제 연산자 기능을 만들어야 된다고 해봅시다. 당신의 팀에 A, B, C, 그리고 D라는 팀원이 있다고 하면,

- A: 더하기 기능
- B: 빼기 기능
- C: 곱하기 기능
- D: 나누기 기능

이런 식으로 팀원 별로 역할을 나누어 각자 다른 방향으로 일을 해나간 뒤에, 나중에 그 일을 합치기만 하면 됩니다.

<!-- 버전관리시스템에 대한 설명은 끝이 남 -->

## 깃이란?

깃은 여러분이 아시는 리눅스 개발 커뮤니티가 만든 분산 버전 관리 시스템입니다. 여러분도 아시다시피 리눅스는 오픈소스 운영체제로서, 전 세계의 개발자들에 의해서 개발되고 배포되고 있습니다. 옛날에는 리눅스를 압축파일과 패치로써 전해졌는데, 2002년에 Bitkeeper라는 분산버전관리 시스템을 사용하였습니다. 그러다가 이제 2005년에 무료로 사용하던 이 관계가 틀어지면서 그들이 직접 분산버전관리 시스템을 개발한 것이 깃입니다.
이러한 깃은 여러가지 특징이 있는데

- 속도
- 심플한 디자인
- 비선형 개발을 위한 강력한 지원
- 완전한 분산
- 큰 프로젝트를 효율적으로 관리할 수 있는 능력

등이 있습니다.

## 깃 설치하기

자 그러면, 이제 깃을 한 번 설치해보도록 하겠습니다. 아마 여러분이 깃이 이미 설치되어 있어도, 업데이트를 하는 것이 좋을 것이기 때문에 같이 해보겠습니다.

- [윈도우 깃 설치](https://git-scm.com/download/win)
- [맥 깃 설치](https://git-scm.com/download/mac)

위의 링크 중, 자신의 운영체제에 맞는 것을 선택하여, 다운로드하고 설치를 진행해 주시면 됩니다.

## 깃 사용하기 전 셋업

깃을 다 설치하고 나서, 깃을 사용 하기 전에 가장 먼저 해주어야 할 것이 저희의 유저이름과 이메일 주소를 세팅하는 것입니다. 이것이 중요한 이유는 모든 깃 커밋이 유저이름과 이메일을 참조하기 때문입니다. 

```
$ git config --global user.name "이름"
$ git config --global user.email "이메일"
```

이것을 한 번만 해주면 됩니다. 그리고 나서 여러분이 깃으로 하는 모든 행동에 깃이 여러분의 이름과 이메일을 참조할 것입니다.

자 이제 저희 세팅이 제대로 되었는지 한 번 확인해보겠습니다.

```
$ git config --list
```

세팅이 제대로 되었다면, user.name과 user.email에 여러분이 입력한 것이 들어가 있을 것입니다.
혹시라도 더 자세히 보고 싶으시다면, [깃 유저네임 셋업하기](https://help.github.com/en/github/using-git/setting-your-username-in-git)를 참조해주세요.

## 도움얻기

깃에 대해서 도움이 필요하다면, 깃 커맨드를 이용해서 도움을 얻을 수 있습니다. 이게 다 영어로 되어있지만, 구글 번역기를 써가면서 보면 대충 이해가 가능합니다.

```
$ git help <verb>
$ git <verb> --help
$ man git-<verb>
```

예를 들어서, commit에 대한 정보를 보고 싶다면,

```
$ git help commit
```

이런 식으로 해주면 됩니다.

## 깃의 기초

자 그 다음으로는, 깃의 기초를 다루어보려고 합니다. 아마도 제가 하는 수업 중에서 이 부분이 가장 중요한 부분이 될 것 같으니 잘 들어주세요.

## 깃 레포지터리를 가지는 방법

보통 깃 레포지터리를 이 두 가지 방법으로 가지게 됩니다.

1. 버젼 관리 시스템이 적용되지 않은 로컬 폴더를 깃 레포지터리로 바꾸는 방법
2. 이미 존재하는 깃 레포지터리를 클론(복사) 하는 방법

## 이미 존재하는 로컬 폴더에 깃 레포지터리 만들기

우리는 한 번도 깃을 써보지 않았으니, 아마 컴퓨터에 깃 레포지터리가 없을 것입니다. 그렇다면, 여러분이 가지고 있는 폴더나 새로운 폴더를 만들어서 깃 레포지터리를 한 번 만들어 보겠습니다.

먼저 여러분의 운영체제에 맞는 커맨드라인 인터페이스를 켜주세요. 그리고 우리가 깃 레포지터리를 만들려는 폴더로 이동을 해주어야 합니다. 

일단 먼저 빈 폴더를 만들어주겠습니다. calculator라는 빈 폴더를 만들어주세요. 그리고 커맨드라인에서 그 폴더로 이동을 해줍니다.

```
cd Desktop/jasmine-calculator
```

그리고 나서, ls -la를 한 번 해주세요. 그러면 일단 아무것도 보이지 않을 것입니다.

자, 이제 깃 레포지터리를 만들어주겠습니다.

```
git init
```

이 명령어를 치면, 깃 레포지터리를 만들어 줄 것입니다. 지금 이 상황에서는, 여러분의 프로젝트 중 어떠한 것들도 track되고 있지 않습니다. 자 그러면 이제, 여기에 몇 가지의 파일을 한 번 만들어보죠. 

<!-- 계산기 파일을 만든다 -->

이렇게 계산기 파일이 이제 작동을 합니다. 이렇게 존재하는 파일들을 버젼컨트롤을 시작하려면, 이 파일들을 track하고 커밋을 해주어야 합니다.

먼저 아래의 명령어를 실행해보겠습니다.

```
$ git status
```

그러면 untracked files에 여러분의 폴더에 있는 파일들이 뜰 것입니다. 저는 이 모든 파일들을 track을 하고 커밋을 해줄 것입니다.

```
$ git add .
$ git commit -m "Initial Commit"
```

그리고 나서 이제 우리는 커밋의 히스토리를 아래의 명령어를 통해서 또 확인해 볼 수 있습니다

```
$ git log
```

## 이미 존재하는 깃 레포지터리 클론(복사)하기

우리는 `git clone <url>` 을 통하여, 이미 존재하고 있는 레포지터리를 복사할 수도 있습니다. 이것이 언제 유용하냐면은, 예를 들어 여러분이 어떤 사람의 프로젝트를 여러분의 프로젝트에 시작점으로 삼는다거나, 코드 등을 참조할 때 사용할 수 있겠죠. 

제가 깃허브에 올려둔 calculator 레포지터리를 한 번 복사해보겠습니다. 먼저 저의 깃허브에 가서, [jasmine-calculator](https://github.com/DaeguDude/jasmine-calculator)라는 레포지터리를 찾습니다.

<!-- 클론 다운로드 사진 올리기 -->

그리고 오른쪽 위에 보시면, clone or download라는 버튼을 클릭해주세요. 그리고 이 주소를 복사해둡니다. 

그리고 다시 저희는 터미널로 돌아와서, 아래의 명령어와 아까 복사한 주소를 같이 입력해줍니다.

```
$ git clone https://github.com/DaeguDude/jasmine-calculator
```

이렇게 해주면, jasmine-calculator라는 이름의 폴더가 생성되고, 그 안에 .git 이라는 서브폴더를 생성한 후, 그 레포지터리 안의 모든 히스토리를 내려받습니다. 확인해보시면 아까 제가 작성한 모든 파일들이 있는 것을 확인해 보실 수 있습니다.

## 깃이 파일을 관리하는 방식과 커밋해보기

자, 이제 저희는 깃이 무엇인지도 알아보았고, 깃 레포지터리를 저희가 직접 생성하거나, 아니면 이미 남이 생성해둔 레포지터리를 불러들이는 법도 알아보았습니다. 이제 저희가 실제로 파일을 만들고, 커밋을 해볼 것입니다. 또한, 이 커밋을 하기 전까지의 깃 레포지터리 안의 파일들의 상태 변화에 대해서도 알아볼 것입니다.

## 차이가 아니라 스냅샷

보통의 버전 관리 시스템들은 파일의 변화에 중점을 두어 관리를 합니다. 어느 한 파일이 있다고 치면, 그 파일이 바뀔 때 마다 파일을 변화를 기록하는 것이죠. 

<!-- 델타 베이스 버전관리 시스템 사진 -->

하지만 깃이 파일을 관리하는 방법은 다릅니다. 깃은 데이터를 스냅샷의 연속처럼 다룹니다. 이것이 무슨 말이냐면, 여러분이 커밋을 하거나 여러분의 폴더의 상태를 저장을 할 때, 깃은 여러분의 폴더의 상태의 스냅샷(사진)을 찍어두고, 그 스냅샷의 링크를 저장해두는 것입니다.

<!-- 깃 버전관리 시스템 사진 -->

## 깃의 세가지 상태

만약 여러분이 나머지를 쉽게 이해하고 싶다면, 이 부분을 정확하게 알고 넘어가는 것이 좋을 것입니다. 사실 나머지를 쉽게 이해할 수 있을 지는 저도 잘 모르겠습니다만, 한 번 해보죠.

깃에서는 파일이 머물 수 있는 세가지 상태가 있습니다.

- 수정된(modified) 상태
- 준비된(staged) 상태
- 완료된(commited) 상태

수정된 상태는 여러분이 파일을 바꾸었지만, 여러분의 데이터베이스에 커밋을 한 상태는 아닙니다.
준비된 상태는 여러분이 수정한 파일을 커밋을 하기 위해 표시를 해둔 상태를 의미합니다.
완료된 상태는, 여러분의 로컬 데이터베이스에 데이터가 안전하게 저장된 상태를 의미합니다.

이러한 상태는 또, 깃 프로젝트의 세가지 큰 부분으로 이끌죠.

<!-- 워킹 디렉토리, 스테이징 에리아, 깃 디렉토리 -->

깃에는 세가지 큰 부분이 있습니다.

- 워킹트리(working tree)
- 스테이징 공간(staging area)
- 깃 폴더(git directory)

보통 저희가 작업을 하면, 흐름은 이렇습니다.

1. 워킹트리에서 파일을 수정합니다.
2. 다음 커밋에 추가할 변화들을 선택하여, 스테이징 부분에 넘겨줍니다.
3. 그리고 스테이징 공간에 있는 파일들을 가져와 커밋을 하고, 이것을 깃 폴더에 영원히 저장합니다.

지금 이것을 이해하려고 하지 않으셔도 됩니다. 실제로 저희가 커밋을 해보면서 다시 설명을 해드리겠습니다.

## 커밋

자, 이제 한 번 커밋을 해보려고 합니다. 그 전에, 여러분의 파일들은 두 가지 상태로 있을 수 있다는 것을 기억해주세요. 여러분들의 파일은

- 추적된(tracked)
- 추적되지 않은(untracked)

중의 하나의 상태로 있습니다. 추적된 상태의 파일은 쉽게 얘기하면 깃이 알고 있는 파일들이고, 추적되지 않은 상태의 파일은 깃이 모르는 파일들 입니다. 

자, 먼저 여러분의 파일들의 상태를 알아보기 위해서 다음의 명령어를 실행해 봅시다.

```
$ git status
```

여러분이 금방 제 레포지터리를 복사했기 때문에, 워킹디렉토리 클린이라는 말을 보게 되실겁니다.
자, 그러면 이제 새로운 파일들을 한 번 추가해보겠습니다. 'README.md' 라는 파일을 한 번 추가해보죠. 

<!-- README.md -->

그리고 다시,

```
$ git status

On branch master
Your branch is up to date with 'origin/master'.

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	README.md

nothing added to commit but untracked files present (use "git add" to track)
```

추적되지 않은 파일의 README.md가 추가된 것이 보이십니까? 이 추적되지 않은 상태의 파일이 의미하는 것은, 깃이 여러분의 마지막 커밋에서 못 봤던 파일이 존재한다는 것입니다. 그래서 깃은 여러분이 직접 깃에게 이 파일을 커밋에 포함시켜라 라고 얘기하지 않는 이상 여러분의 커밋에 추가시키지 않을 것입니다.

그러면 이 파일을 한 번 추적된 상태로 만들어보죠. 깃이 알고있는 상태로 만들 것입니다.

```
$ git add README.md
$ git status

On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	new file:   README.md
```

자, 위의 결과물을 보시면, 우리의 파일은 이제 추적된 상태로 변하였고, 워킹 트리에서 스테이징 공간으로 넘어가 커밋을 할 준비가 되어 있습니다. 그래서 여러분이 커밋을 한다면, 이제 우리가 git add 를 해주었을 당시의 파일의 상태가 커밋이 되는 것이죠.

### Staging Modified Files(추적된 상태의 파일을 준비시키기)

자, 이번에는 이미 추적된 상태의 파일을 다시 스테이징 공간으로 옮기고, 커밋을 해보겠습니다. script.js의 파일에 주석을 달아주고, 다시 한 번 깃을 확인해보겠습니다. 

```
$ git status
On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	new file:   README.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   script.js
```

결과를 한 번 확인해보면, 저희가 아까 올려둔 README 파일은 이미 커밋을 할 준비가 되어있고, script.js라는 파일은 변화가 있었지만, 커밋을 할 준비가 안 되어있다고 나옵니다. 이것이 무엇을 뜻하냐면, 파일은 추적된 상태로 있고, 수정되었지만, 커밋을 하기 위한 준비는 되어있지 않다는 뜻입니다. 이것은 추적된 파일이 워킹트리에서 수정이 되었지만, 스테이징 공간으로 옮겨지지는 않았다는 것을 의미합니다. 그러면 다시 스테이징 공간으로 'script.js' 파일을 옮겨봅시다.

```
$ git add script.js
$ git status
On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	new file:   README.md
	modified:   script.js
```

이제 두 파일이 모두 스테이징 공간으로 옮겨서 커밋을 할 준비가 완료되었습니다. 두 파일이 모두 준비가 되었기 때문에, 저희는 이제 커밋만 해주면 됩니다.

```
$ git commit -m "my commit"

[master f6ebb31] my commit
 2 files changed, 3 insertions(+), 2 deletions(-)
 create mode 100644 README.md
```

이런 식으로 커밋이 완료되면 메세지가 뜰 것입니다. 그리고 저희의 커밋의 히스토리르 보려면,

```
$ git log
```
를 실행해서 이때까지의 커밋의 히스토리를 볼 수 있습니다.

## 특정파일 제외시키기

예를 들어, 우리가 다른 사람의 레포지터리를 내려받아서 개발을 하다보면, 그 폴더안에 팀 전체에 필요한 것이 아닌 나에게만 필요한 프로그래밍 개발일지를 작성한다거나, 테스트 일지를 만든다거나 등등 팀 전체에는 불필요한 파일들을 생성하게 되는 경우가 있습니다. 이러한 경우에는 팀과 협력을 하고 있는 경우, 이러한 파일들이 커밋이 되면 안되겠죠? 그래서 깃에는, 이러한 파일들을 제외시킬 수 있습니다. 이러한 파일들을 `git status`를 실행하여도, untracked라고 나타나지도 않을 것입니다. 우리는 우리가 제외시키고 싶은 파일들을, `.gitignore`이라는 파일에 넣어 주면 됩니다. 예를 들어, test라는 폴더를 만들고 그 밑에 몇 개의 파일을 생성하였습니다. 그리고 git status를 실행하면, untracked files에 이 폴더가 뜰 것입니다. 하지만 gitignore에 가서 test폴더를 무시해 라고 설정을 해준다면, 더 이상 깃에서는 그 폴더를 커밋에 포함시키지 않을 것입니다.

<!-- test 폴더를 만듬 -->

## 기본적인 원상복구

이번에는, 기본적인 원상복구 방법에 대해서 한 번 알아보겠습니다. 저희가 깃을 쓰다보면, 여러가지 실수를 하게되죠. 저희가 할 수 있는 실수들에 대해서 한 번 알아보고, 어떻게 대처할 수 있는지 한 번 알아보겠습니다.

### amend

amend는 이미 커밋이 되었지만,

- 메세지를 잘못 입력
- 커밋에 파일을 추가하는 것을 까먹었음
- 파일에 오타가 있음

경우에 사용할 수 있습니다. 먼저 메세지를 잘못 입력했을 때를 알아보겠습니다.
예를 들어, 우리가 `script.js` 폴더에서, 빼기 함수를 수정하고, 커밋을 한다고 해봅시다. 그런데 메세지를, 곱하기를 수정했다고 잘못 입력하였습니다.

```
$ git add .
$ git commit -m "Multiply function fixed"
```

이럴 때는, 아주 손 쉽게 다음 명령어를 입력해주면 됩니다.

```
$ git commit --amend -m "Subtract Function Fixed"
```

그러면, 우리는 새로운 커밋을 만들지 않고, 가장 최근의 커밋의 메세지를 바꾼 것을 확인해 볼 수 있습니다.

만약, 여러분이 가장 최근의 커밋에 어떤 파일을 추가하는 것을 까먹었다고 했을 때도, amend라는 명령어를 써서 가장 최근의 커밋에 여러분이 까먹은 파일을 추가시킬 수도 있습니다. git commit amend는, 스테이징 공간에 있는 내용을 가져와, 커밋을 수정합니다. 예를 들어, `logbook.txt` 라는 파일을 만들고, 이것을 우리가 아까 수정한 커밋에 포함시켜봅시다. 그러면, amend가 스테이징 공간에 있는 내용을 가져와 커밋을 수정하기 때문에 먼저 스테이징 공간에 logbook.txt를 포함시켜야 겠지요? 그런 다음, amend 명령어를 실행해주면, 스테이징 공간에 있는 내용이 가장 최근의 커밋에 포함되는 것을 보실 수 있습니다.

```
$ git add logbook.txt
$ git commit --amend

Subtract function fixed

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# Date:      Wed May 27 10:47:43 2020 +0900
#
# On branch master
# Your branch is ahead of 'origin/master' by 5 commits.
#   (use "git push" to publish your local commits)
#
# Changes to be committed:
#       new file:   logbook.txt
#       new file:   script.js
#
```

이런 식으로, amend는 가장 최근의 커밋에 무엇인가를 포함시켜야 되거나, 메세지를 고치거나, 파일에 오타가 있었다거나 등등 아주 작은 변화를 고칠 때 유용합니다.

### restore

이번에는 restore 명령어에 대해서 알아볼 것입니다. 예를 들어, 여러분이 여러분만의 해야 할 일을 담은 `todolist.txt` 라는 파일을 생성해봅시다. 그리고 우리는 script.js의 함수들을 console.log로 다 바꾸어 주었습니다. 그리고 나서 이제 파일을 워킹트리에서 스테이징 공간으로 옮겨보죠.

```
$ git add .
$ git status

On branch master
Your branch is ahead of 'origin/master' by 5 commits.
  (use "git push" to publish your local commits)

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	modified:   script.js
	new file:   todolist.txt
```

`script.js`와 `todolist.txt` 파일은 이제 커밋을 할 준비가 되어있습니다. 하지만, 생각해보니 todolist 파일은 여러분만의 todolist이기 때문에 커밋에 포함시키면 안 된다는 걸 여러분은 깨달았습니다. 그 때 쓸 수 있는 것이 이제 restore 명령어입니다. restore 명령어를 실행해서, 다시 워킹트리로 옮겨보겠습니다.

```
$ git restore --staged todolist.txt
$ git status

On branch master
Your branch is ahead of 'origin/master' by 5 commits.
  (use "git push" to publish your local commits)

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	modified:   script.js

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	todolist.txt
```

그러면 우리는 다시 todolist 파일이 스테이징 공간에서 워킹트리로 옮겨진 것을 확인할 수 있습니다. 

또한 우리는 restore 옵션을, 우리가 파일에 만든 변화가 마음에 들지 않을 때도 사용할 수 있습니다. 예를 들어, return을 console.log로 바꾼 것은 잘못된 선택이었다고 생각이 들어, 다시 옛날의 상태로 돌려봅시다. 먼저, 스테이징 공간에서 워킹트리로 다시 옮겨줍니다.

```
$ git restore --staged script.js
$ git status

On branch master
Your branch is ahead of 'origin/master' by 5 commits.
  (use "git push" to publish your local commits)

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   script.js

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	todolist.txt
```

그런 다음, 결과물을 확인해보면 script.js가 변화는 있었지만, 커밋을 할 준비는 되어있지 않다라고 되어있는 것이 보이시죠? 우리는 이 변화를 돌려줄 것입니다.
우리가 해야할 것은 restore를 한 번 더 해주면 됩니다.

```
$ git restore script.js
```

그러면, 우리의 파일이 원래대로 돌아간 것을 확인할 수 있을 것입니다.







