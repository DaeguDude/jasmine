# 스코프(scope)란 무엇인가?

프로그래밍 언어에 있어서 가장 기초적인 개념중 하나가 값을 변수에 저장하고 나중에 그 값을 불러오고 수정할 수 있다는 것일 겁니다. 이러한 개념이 없었다면 아마 프로그램이 할 수 있는 것은 많이 없었을 것입니다. 

아마도 여러분은 이런 생각을 한 번쯤은 해봤을 건데요. 

> '변수는 도대체 어디에 생성되는 거지?' '프로그램이 변수를 어떻게 찾는거지?'

변수를 어떠한 위치에 저장할 때는, 사실 특정한 규칙을 따라서 저장을 합니다. 그리고 변수를 찾을 때도 그 규칙에 따라 변수를 찾죠. 우리는 이러한 규칙을 **스코프**라고 부릅니다.

<!-- ## 스코프는 어떻게 만들어질까? 

스코프가 어떻게 만들어지는 지에 대해서를 알려면 조금 이론적인 부분이 필요한데요. 저의 내용 이해도도 깊지 않고, 학문적이여 질 수 있기 때문에 최소한으로 설명을 해보겠습니다.

자바스크립트는 '다이나믹' 그리고 '인터프리티드' 언어라고 하는데요. 사실 자바스크립트는 컴파일 언어입니다. 컴파일러가 코드를 컴파일하는 것이죠. -->

이번 포스트에서는, 스코프가 어떻게 지정 되는지에 대한 자세한 원리가 아닌, 우리가 프로그램을 더 쉽게 짤 수 있게, 실용적인 면에 대해서 조금 더 집중해보도록 하겠습니다.


<!-- ## 컴파일러 이론(Compiler Theory)

아마도 여러분은 자바스크립트가 '다이나믹' 혹은 '인터프리티드(interpreted)' 언어라고 들으셨을 텐데요. 사실은 컴파일 언어입니다. 우리가 아는 다른 언어들처럼, 실행전에 모든게 컴파일되지는 않지만, 실로 컴파일 언어입니다.

보통 컴파일 언어에서는, 여러분이 작성한 코드 즉 프로그램이 실행되기 전에 3가지의 단계를 거칠 것입니다. 이것을 컴파일(compliation)이라고 합니다.

1. **토큰화/렉싱(Tokenizing/Lexing)**: 문자들을 의미있는 단위로 나눕니다. 이 의미있는 단어를 우리는 토큰이라고 부르죠. `var a = 2;`를 한 번 예로 들어볼게요. 이 프로그램은 아마 이러한 토큰으로 나뉠 겁니다: `var`, `a`, `=`, `2`, 그리고 `;`요. 공백은 토큰이 될 수도 있고 안 될 수도 있는데 이것은 문맥에 따라 다릅니다.


**노트**: 토큰화와 렉싱의 차이는 아주 미묘하고 학문적인데 가장 중요한 것은 이 토큰들이 중요한 것인지 

2. **파싱(Parsing)**: 위에서 토큰화된 토큰들을 가지고 중첩된 요소들로 구성된 트리를 만듭니다. 이 트리(tree)가 프로그램의 문법적인 구조를 나타내죠. 이 트리는 'AST(Abstract Syntax Tree)'라고 불립니다. 

`var a = 2;`의 트리는, `VariableDeclaration` 이라는 최상위 노드를 가질 것이고, 자식노드인 `Identifier`(이 것의 값은 `a`겠죠)를 가질 겁니다. 또한 또 다른 자식노드인 `AssignmentExpression`이 있을 것이고, 이 노드는 `NumericLiteral`(이 것의 값은 `2`겠죠) 이라는 자식을 가질 것입니다.

3. **코드생성(Code-Generation)**: 이 절차는 위에서 생성된 AST를 가지고 실행 가능한 코드로 변환시키는 절차입니다. 너무 복잡하게 생각하지 말고 간단하게 생각하면, `var a = 2;`로 인해 생성된 트리(AST)를 가지고 기계적인 절차를 만들어 `a`라는 변수를 생성하고 `2`라는 값을 `a`에 저장한다고 생각하시면 됩니다. 

자바스크립트 엔진은 위에서 얘기한 3가지 절차보다 사실 더 복잡하기는 하지만, 기본적인 것은 비슷합니다. 한 가지 주의를 하자면, 자바스크립트 엔진은 다른 컴파일러들과는 달리 컴파일을 하기에 많은 시간이 주어지지 않기 때문에 여러가지 기술들을 많이 씁니다. 그 예시로는 'JIT', 'Lazy Compile' 그리고 'hot re-compile'이라는 것들이 있는데, 저희가 아직 이해할 단계는 아닙니다.

우리의 이해를 돕기 위해서, 자바스크립트의 모든 코드들은 실행이 되기전에 컴파일이 된다고 생각을 하는 게 좋을 겁니다. 그래서, 자바스크립트 컴파일러는 `var a = 2;`라는 프로그램을 먼저 컴파일하고, 그 다음에 실행을 할 것입니다. -->


## 렉시컬 스코프(Lexical Scope)

제가 아까 '스코프(scope)'란 변수를 찾기 위한 규칙이라고 얘기하였습니다. 스코프에는 두 가지 주요한 모델이 있는데요. 첫번째로는 가장 많은 프로그래밍 언어에서 쓰이는 **'렉시컬 스코프(Lexical Scope)'**입니다. 두번째로는 몇몇 언어들에서 쓰이는 **'다이나믹 스코프'**가 있습니다. 

우리가 사용하는 자바스크립트는 렉시컬 스코프를 사용하는데요. 한 번 자세히 알아보겠습니다.
자바스크립트 언어는 실제로 컴파일 언어인데요. 보통 컴파일러들이 코드를 컴파일 할 때 가장 먼저 하는 것이 렉싱(lexing 혹은 토큰화(tokenizing))입니다. 

이 렉싱을 하는 과정에서 만들어지는 스코프가 **렉시컬 스코프**입니다. 쉽게 얘기하자면, 컴파일러가 여러분의 코드를 처리하면서 만들어내는 스코프이죠.

한 번 예시를 보겠습니다.

```javascript
function foo(a) {
    var b = a * 2;

    function bar(c) {
        console.log(a, b, c);
    }

    bar(b * 3);
}

foo(2);
```

위의 예시에서는 세 개의 중첩된 스코프가 있는데요. 스코프를 방울이라고 생각하시면 이해가 더 쉬울 수도 있을 것 같습니다.

<!-- 스코프 그림 넣기 -->

**방울 1**는 글로벌 스코프에 속하고, 한 개의 식별자만 있습니다: `foo`

**방울 2**는 `foo` 스코프에 속하는데, 3개의 식별자들이 있습니다: `a`, `bar`, `b`

**방울 3**는 `bar` 스코프에 속하는데, 1 개의 식별자가 있습니다: `c`


<!-- 더 정밀한 설명이 필요함 -->
일단 아주 간단하게 함수는 새로운 스코프를 생성한다고 가정을 하겠습니다. 그렇다면, `bar` 방울은, `foo`의 방울안에 가둬져 있겠죠. 왜냐하면 `bar`가 `foo` 방울 안에서 생성이 되었으니까요.

위의 예시에서는, `console.log(...)` 문이 실행이 될 때, `a`, `b`, 그리고 `c` 세 개의 변수를 찾습니다. 어떤 변수를 찾을 때 가장 먼저 찾기 시작하는 곳은 가장 안 쪽에 있는 스코프입니다. 여기서는 `bar` 스코프가 되겠죠. 만약에 여기서 `a`를 찾지 못한다면, 한 단계 올라갑니다. 여기서는 `foo` 스코프가 되겠죠. `b`와 `c` 변수도 똑같습니다. 하지만 `c`를 보시면, `bar` 스코프에서 바로 찾겠죠.

**여기서 중요한 점은 이렇게 변수가 위치한 스코프를 찾는 과정이 변수를 찾으면 바로 멈춘다는 것입니다.** 예를 들어서, 위의 예시에서 `bar` 함수가 실행될 때, `c`를 `bar` 스코프에서 바로 찾았기 때문에 멈추겠죠. 더 이상 위로 올라가지 않습니다.

## 함수 스코프 vs 블락 스코프

우리가 위에서 배웠듯이, 스코프는 식별자(변수, 함수)들이 선언된 방울(공간)들을 얘기합니다. 이러한 방울들은 다른 방울의 안에 중첩될 수 있죠.

그런데 이러한 방울은 만드는 것은 함수밖에 없을까요? 자바스크립트에서 다른 어떠한 것이 이러한 방울을 또 생성할 수 있을까요?

### 함수 스코프

먼저 아까 얘기하였듯이 함수는 스코프(방울)을 생성합니다. 그래서 여러분이 새로운 함수를 만들때마다 새로운 스코프를 생성하는 것이죠.

예시를 한 번 살펴볼게요.

```javascript
function foo(a) {
    var b = 2;

    function bar() {
        console.log('I am bar function');
    }

    var c = 3;
}
```

위의 예시에서는 `foo` 스코프가 `a`, `b`, `c`, 그리고 `bar` 라는 식별자를 가지고 있습니다. 그리고 보시면 `bar` 도 함수이기 때문에 자기 자신만의 스코프를 가지고 있겠죠. 

제가 `foo` 스코프 안에 있는 식별자들에 한 번 접근을 해보겠습니다.

```javascript
console.log(b); // Uncaught ReferenceError: b is not defined
console.log(c); // Uncaught ReferenceError: c is not defined
bar(); // Uncaught ReferenceError: bar is not defined
```

이렇게 함수 스코프는 식별자들을 숨길 수 있습니다. 그리고 이러한 기능은 나중에 아주 유용해집니다. 

### 블락 스코프

이제까지는 스코프를 생성하려면 함수를 쓰는 수 밖에 없었지만 사실은 블락 스코프라는 것이 있습니다. 그리고 다른 프로그래밍 언어들이 블락 스코프를 지원을 하죠. 

한 번 예시를 볼게요.

```javascript
for (var i = 0; i < 10; i++) {
    console.log(i);
}
// 0, 1, 2, .... 9

console.log(i); // 10
```

우리의 목적은 아마 `i` 라는 변수를 for 반복문에서만 쓰는 것일 것입니다. 하지만 반복문이 다 실행되고 나서도 우리는 `i` 변수에 접근을 할 수가 있습니다. 이것은 아마도 우리가 원하는 게 아닐 겁니다. 위의 예시는 for 반복문을 감싸고 있는 스코프를 더럽히고 있죠.

블락스코프는 "Principle of Least Privilege" 라는 개념을 조금 더 연장하는 개념입니다. 이것이 무엇이냐면은 최소한의 필요한 권한만 노출을 시킨다는 개념입니다.

### let

다행스럽게도 ES6에서는 `var`와 함께 새롭게 변수를 선언하는 키워드인 `let`을 도입하였습니다. 
`let` 키워드가 하는 일은 변수 선언을 자기 자신이 선언되는 블락에 붙여버립니다.

```javascript
if (true) {
    let bar = 3;
    console.log(bar); // 3
}

console.log(bar); // 에러!!

```

### const

`let` 키워드와 `const` 라는 키워드도 있는데요. 이것도 블락 스코프 변수를 생성합니다. 하지만 이 변수의 값은 변할 수 없습니다(상수). 나중에 값을 변경하려 하면 오류가 생기죠.

```javascript
var foo = true;
if (foo) {
    var a = 2;
    const b = 3;

    a = 3;
    b = 4;
}

console.log(a);
console.log(b);
```

### 정리

자바스크립트에서 함수는 스코프를 생성하는 가장 흔한 유닛입니다. 그리고 함수 안에 생성되는 또 다른 함수는 감싸고 있는 함수에 의해서 숨겨지게 되죠. 좋은 소프트웨어 디자인의 원칙이기도 합니다.

하지만 함수만이 스코프를 생성하는 것은 아닙니다. 블락 스코프도 있는데요. 블락 스코프란 변수나 함수가 어떠한 블락(`{...}`)에 속하게 되는 것을 얘기합니다.

## 호이스팅

지금 쯤이면 아마 여러분들은 스코프에 대해서 잘 이해를 하고 있다고 생각이 듭니다. 간단하게 정리하자면, 함수 스코프든 블락 스코프이든 그 스코프 안에서 생성 되는 변수들은 그 스코프에 속하게 된다는 규칙은 같습니다. 그런데 두 개 간의 아주 작은 차이가 있는데요. 한 번 살펴보겠습니다.

### 닭이 먼저일까 달걀이 먼저일까?

아마도 여러분은 여러분이 작성한 자바스크립트 코드가 위에서부터 아래로 한 줄 한 줄씩 실행된다고 생각하실 겁니다. 사실 이 말은 맞는 말이긴 하지만, 주의해야 할 점이 하나 있습니다.

```javascript
a = 2;

var a;

console.log(a);
```

위의 예시를 보면, 여러분은 `console.log` 문이 어떠한 결과물을 출력할 것이라 생각이 드나요?

`var a;`가 `a = 2;` 보다 늦게 선언이 되었기 때문에 아마도 많은 사람들이 `undefined` 를 생각할 것입니다. 하지만 실제로는 `2`가 출력이 됩니다.

또 다른 예시를 보시면,
```javascript
console.log(a);

var a = 2;
```

여러분은 어떤 것이 출력될 것이라고 생각하시나요? 아마도 먼저의 예시에서 `2`가 제대로 출력이 되었기 때문에 이번에도 `2`가 출력이 될 것이라 생각할 겁니다. 아니라면, `a`가 변수가 선언되기 전에 사용되었기 때문에 `ReferenceError`가 발생할 것이라고도 생각할 수 있습니다. 하지만, 둘 다 틀렸고 결과값은 `undefined`가 나옵니다.

**무슨 일이 일어난 걸까요?** 치킨(변수 선언)이 먼저일까요 달걀이(대입) 먼저일까요?

## 컴파일러 이론

이것을 이해하기 위해서는 약간의 학문적인 이론이 필요한데요. 여러분의 코드가 실행되기 전에 컴파일러라는 것이 자바스크립트 엔진이 코드를 실행할 수 있게 코드를 컴파일 시켜주는 과정이 있습니다.

<!-- 컴파일러와 자바스크립트 사진 넣기 -->

그래서 이것을 아주 이해하기 쉽게 하기위해서는, 여러분의 변수와 함수는 여러분의 코드가 실행되기 전에 먼저 선언된다고 생각을 하시면 됩니다.

여러분이 `var a = 2;`를 보시면 아마도 이것이 한 개의 구문이라고 생각하겠지만, 자바스크립트는 이것을 두 개의 구문으로 생각을 합니다: `var a;`와 `a = 2;`로요. 첫번째 구문은 선언문이고, 두번째 구문은 대입문이겠죠.

그래서 위의 첫번째 예시는 아마 이런 식으로 실행 되었을 겁니다.

```javascript
var a;

a = 2;

console.log(a);
```

그리고 두번째 예시는 이렇게 실행 되었겠죠.
```javascript
var a;

console.log(a);

a = 2;
```

이러한 절차를 한 번 비유적으로 이해해본다면, 변수와 함수 선언문들은 코드의 가장 맨 위로 옮겨진다고 생각을 하면 쉬울 것 같습니다. 그리고 이렇게 옮겨지는 과정을 우리는 '호이스팅(Hositing)' 이라고 하죠.

**다른 말로 해서 달걀(선언)이 치킨(대입)보다 먼저인 경우입니다.**

여기서 중요한 점은 선언문만 옮겨지는 것이지 값을 대입하는 논리들은 그 자리에 그대로 있습니다.

이 예시는,

```javascript
foo();

function foo() {
    console.log(a); // undefined

    var a = 2;
}
```

아마 이렇게 해석이 되겠죠.

```javascript
function foo() {
    var a;

    console.log(a);

    a = 2;
}

foo();
```

함수 선언문은 우리가 보다시피 호이스트 됩니다. **하지만 함수 표현식은 아닙니다.**
```javascript
foo(); // Uncaught TypeError: foo is not a function

var foo = function bar() {
    console.log('I cannot be hoisted');
};
```

보시면 식별자 `foo`는 감싸고 있는 스코프에 호이스팅 됩니다. 

```javascript
var foo;

foo(); // foo는 함수가 아닙니다!!

foo = function bar() {
    console.log('I cannot be hoisted');
}
```

아마 이런식으로 코드가 진행이 되었겠죠.

### 변수보다 함수가 먼저입니다

함수와 변수 선언문 둘 다 호이스팅 되는데 하지만 약간의 차이는 있습니다. 함수가 먼저 호이스팅되고 그 다음 변수가 호이스팅 됩니다.

```javascript
foo();

var foo;

function foo() {
    console.log(1);
}

foo = function() {
    console.log(2);
}
```

```javascript
function foo() {
    console.log(1);
}

var foo; // `foo`라는 식별자가 겹치기 때문에 무시됩니다.

foo();

foo = function() {
    console.log(2);
}
```

### 정리하자면...

우리는 보통 `var a = 2;`를 볼 때 한 개의 구문으로 보지만 자바스크립트 엔진은 그렇게 생각하지 않습니다. `var a;`와 `a = 2;`로 생각을 하게되죠. 첫번째 구문은 컴파일을 할 때 발생되고, 두번째 구문은 실행을 할 때 발생되죠.

이것이 무엇을 의미하냐면은 스코프안에 있는 모든 선언문은 어디에서 나타나든, 코드가 실행되기 전에 먼저 선언이 된다는 것입니다. 아마 이것을 코드의 맨 위로 옮겨진다고 생각을 하면 되는데, 이것을 **"호이스팅(Hoisting)"** 이라고 부릅니다.

함수 선언문은 호이스팅 되지만, 함수 표현식은 호이스팅 되지 않습니다!



