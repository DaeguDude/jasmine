# 스코프(scope)란 무엇인가?

프로그래밍 언어에 있어서 가장 기초적인 개념중 하나가 값을 변수에 저장하고 나중에 그 값을 불러오고 수정할 수 있다는 것일 겁니다. 이러한 개념이 없었다면 아마 프로그램이 할 수 있는 것은 많이 없었을 것입니다. 

아마도 여러분은 이런 생각을 한 번쯤은 해봤을 건데요. 

> '변수는 도대체 어디에 생성되는 거지?' '프로그램이 변수를 어떻게 찾는거지?'

변수를 어떠한 위치에 저장할 때는, 사실 특정한 규칙을 따라서 저장을 합니다. 그리고 변수를 찾을 때도 그 규칙에 따라 변수를 찾죠. 우리는 이러한 규칙을 **스코프**라고 부릅니다.

<!-- ## 스코프는 어떻게 만들어질까? 

스코프가 어떻게 만들어지는 지에 대해서를 알려면 조금 이론적인 부분이 필요한데요. 저의 내용 이해도도 깊지 않고, 학문적이여 질 수 있기 때문에 최소한으로 설명을 해보겠습니다.

자바스크립트는 '다이나믹' 그리고 '인터프리티드' 언어라고 하는데요. 사실 자바스크립트는 컴파일 언어입니다. 컴파일러가 코드를 컴파일하는 것이죠. -->

이번 포스트에서는, 스코프가 어떻게 지정 되는지에 대한 자세한 원리가 아닌, 우리가 프로그램을 더 쉽게 짤 수 있게, 실용적인 면에 대해서 조금 더 집중해보도록 하겠습니다.


<!-- ## 컴파일러 이론(Compiler Theory)

아마도 여러분은 자바스크립트가 '다이나믹' 혹은 '인터프리티드(interpreted)' 언어라고 들으셨을 텐데요. 사실은 컴파일 언어입니다. 우리가 아는 다른 언어들처럼, 실행전에 모든게 컴파일되지는 않지만, 실로 컴파일 언어입니다.

보통 컴파일 언어에서는, 여러분이 작성한 코드 즉 프로그램이 실행되기 전에 3가지의 단계를 거칠 것입니다. 이것을 컴파일(compliation)이라고 합니다.

1. **토큰화/렉싱(Tokenizing/Lexing)**: 문자들을 의미있는 단위로 나눕니다. 이 의미있는 단어를 우리는 토큰이라고 부르죠. `var a = 2;`를 한 번 예로 들어볼게요. 이 프로그램은 아마 이러한 토큰으로 나뉠 겁니다: `var`, `a`, `=`, `2`, 그리고 `;`요. 공백은 토큰이 될 수도 있고 안 될 수도 있는데 이것은 문맥에 따라 다릅니다.


**노트**: 토큰화와 렉싱의 차이는 아주 미묘하고 학문적인데 가장 중요한 것은 이 토큰들이 중요한 것인지 

2. **파싱(Parsing)**: 위에서 토큰화된 토큰들을 가지고 중첩된 요소들로 구성된 트리를 만듭니다. 이 트리(tree)가 프로그램의 문법적인 구조를 나타내죠. 이 트리는 'AST(Abstract Syntax Tree)'라고 불립니다. 

`var a = 2;`의 트리는, `VariableDeclaration` 이라는 최상위 노드를 가질 것이고, 자식노드인 `Identifier`(이 것의 값은 `a`겠죠)를 가질 겁니다. 또한 또 다른 자식노드인 `AssignmentExpression`이 있을 것이고, 이 노드는 `NumericLiteral`(이 것의 값은 `2`겠죠) 이라는 자식을 가질 것입니다.

3. **코드생성(Code-Generation)**: 이 절차는 위에서 생성된 AST를 가지고 실행 가능한 코드로 변환시키는 절차입니다. 너무 복잡하게 생각하지 말고 간단하게 생각하면, `var a = 2;`로 인해 생성된 트리(AST)를 가지고 기계적인 절차를 만들어 `a`라는 변수를 생성하고 `2`라는 값을 `a`에 저장한다고 생각하시면 됩니다. 

자바스크립트 엔진은 위에서 얘기한 3가지 절차보다 사실 더 복잡하기는 하지만, 기본적인 것은 비슷합니다. 한 가지 주의를 하자면, 자바스크립트 엔진은 다른 컴파일러들과는 달리 컴파일을 하기에 많은 시간이 주어지지 않기 때문에 여러가지 기술들을 많이 씁니다. 그 예시로는 'JIT', 'Lazy Compile' 그리고 'hot re-compile'이라는 것들이 있는데, 저희가 아직 이해할 단계는 아닙니다.

우리의 이해를 돕기 위해서, 자바스크립트의 모든 코드들은 실행이 되기전에 컴파일이 된다고 생각을 하는 게 좋을 겁니다. 그래서, 자바스크립트 컴파일러는 `var a = 2;`라는 프로그램을 먼저 컴파일하고, 그 다음에 실행을 할 것입니다. -->


## 렉시컬 스코프(Lexical Scope)

제가 아까 '스코프(scope)'란 변수를 찾기 위한 규칙이라고 얘기하였습니다. 스코프에는 두 가지 주요한 모델이 있는데요. 첫번째로는 가장 많은 프로그래밍 언어에서 쓰이는 **'렉시컬 스코프(Lexical Scope)'**입니다. 두번째로는 몇몇 언어들에서 쓰이는 **'다이나믹 스코프'**가 있습니다. 

우리가 사용하는 자바스크립트는 렉시컬 스코프를 사용하는데요. 한 번 자세히 알아보겠습니다.
자바스크립트 언어는 실제로 컴파일 언어인데요. 보통 컴파일러들이 코드를 컴파일 할 때 가장 먼저 하는 것이 렉싱(lexing 혹은 토큰화(tokenizing))입니다. 

이 렉싱을 하는 과정에서 만들어지는 스코프가 **렉시컬 스코프**입니다. 쉽게 얘기하자면, 컴파일러가 여러분의 코드를 처리하면서 만들어내는 스코프이죠.

한 번 예시를 보겠습니다.

```javascript
function foo(a) {
    var b = a * 2;

    function bar(c) {
        console.log(a, b, c);
    }

    bar(b * 3);
}

foo(2);
```

위의 예시에서는 세 개의 중첩된 스코프가 있는데요. 스코프를 방울이라고 생각하시면 이해가 더 쉬울 수도 있을 것 같습니다.

<!-- 스코프 그림 넣기 -->

**방울 1**는 글로벌 스코프에 속하고, 한 개의 식별자만 있습니다: `foo`

**방울 2**는 `foo` 스코프에 속하는데, 3개의 식별자들이 있습니다: `a`, `bar`, `b`

**방울 3**는 `bar` 스코프에 속하는데, 1 개의 식별자가 있습니다: `c`


<!-- 더 정밀한 설명이 필요함 -->
일단 아주 간단하게 함수는 새로운 스코프를 생성한다고 가정을 하겠습니다. 그렇다면, `bar` 방울은, `foo`의 방울안에 가둬져 있겠죠. 왜냐하면 `bar`가 `foo` 방울 안에서 생성이 되었으니까요.

위의 예시에서는, `console.log(...)` 문이 실행이 될 때, `a`, `b`, 그리고 `c` 세 개의 변수를 찾습니다. 어떤 변수를 찾을 때 가장 먼저 찾기 시작하는 곳은 가장 안 쪽에 있는 스코프입니다. 여기서는 `bar` 스코프가 되겠죠. 만약에 여기서 `a`를 찾지 못한다면, 한 단계 올라갑니다. 여기서는 `foo` 스코프가 되겠죠. `b`와 `c` 변수도 똑같습니다. 하지만 `c`를 보시면, `bar` 스코프에서 바로 찾겠죠.

**여기서 중요한 점은 이렇게 변수가 위치한 스코프를 찾는 과정이 변수를 찾으면 바로 멈춘다는 것입니다.** 예를 들어서, 위의 예시에서 `bar` 함수가 실행될 때, `c`를 `bar` 스코프에서 바로 찾았기 때문에 멈추겠죠. 더 이상 위로 올라가지 않습니다.



