## 모듈패턴(Module Pattern)

주의: ES6에서 서로 다른 파일 간에 코드를 사용할 수 있는 '모듈' 이라는 새로운 기능이 생겼습니다. `import`와 `export`를 이용해서 사용할 수 있죠. 하지만 여기서 제가 얘기하고자 하는 것은 아닙니다. 나중에 여기에 대해서 한 번 다루겠습니다.

모듈은 팩토리 함수와 아주 비슷합니다. 가장 큰 차이점은 만들어지는 방법이죠.

```javascript
const Calculator = (() => {

    const add = (a, b) => a + b;
    const subtract = (a, b) => a - b;
    const multiply = (a, b) => a * b;
    const divide = (a, b) => a / b;
    
    return { add, subtract, multiply, divide };   
})();

calculator.add(3, 5); // 8
calculator.subtract(6, 2); // 4
calculator.multiply(14, 3); // 42
```

위의 예시를 보고 너무 놀라지 마세요. 위의 예시는 **즉시 실행 함수**(Immediately Invoked Function Expression)라는 것인데, 문법이 어려워보여도 아주 간단합니다.

자바스크립트에서 함수는 함수 선언을 통해서나, 함수 표현식을 통해서 생성이 되죠.

```javascript
// 함수 선언문
function add() {}

// 함수 표현식
const add = function() {}
```

또한 자바스크립트에서는, 어떠한 것을 `괄호()`로 감싸준다면 그것은 표현식이 됩니다. 표현식의 특징은 어떠한 값을 반환한다는 것이죠. 

그래서 밑의 예시를 보면,

```javascript
const add = (function() {
    // 실행될코드
})();
```

먼저 익명 함수 `function() {}` 를 만들고, 그것을 괄호로 감싸줍니다. 
그러면 이렇게 되겠죠. `(function() {})`. 표현식이 되었기 때문에 우리는 이 함수를 반환을 해줄 것입니다. 그리고 나서 이 함수를 `()` 호출을 통해 바로 호출을 시키는 것입니다.

```javascript
(function() {}) // 함수를 반환하기 위한 괄호
() // 호출을 위한 괄호;
```

그러면 코드가 어떻게 동작하는 지는 알겠는데 이것을 왜 사용해야 할까요?
우리가 알고 있듯이 함수는 자신만의 스코프를 생성합니다. 우리는 이렇게 스코프를 생성함으로써 글로벌 스코프를 깔끔하게 해 줄 수 있죠. 글로벌 스코프를 깔끔하게 해주면 우리는 **네임스페이스(namespace)** 라는 것을 사용해 줄 수 있습니다.

네임스페이스란 우리의 프로그램에서 일어나는 이름 충돌의 가능성을 막아주는 방법입니다. 여러분이 작성하는 프로그램이 점점 커진다면 같은 이름의 함수를 가지는 것은 아주 흔한 일입니다. 

예를 들어서, 우리가 웹에서 동작하는 계산기를 만들었다고 가정해볼게요. 화면에 HTML 요소를 추가해주는 함수와, 더하기 연산을 해주는 함수는 `add` 라는 똑같은 이름을 쓰는게 어떻게 보면 이해가 됩니다. 그런데 글로벌 스코프에 두 개다 선언을 하는 것은 불가능하죠. 그래서 우리는 네임스페이스 라는 방법을 이용해, 각자의 스코프를 만들어 이름의 충돌을 
막아주는 것입니다.

```javascript
// 화면에 HTML 요소추가
DisplayController.add();

// 계산기 더하기 기능 실행
Calculator.add();
```

위의 예시처럼 한다면, 똑같은 `add` 라는 이름의 함수를 쓰지만 각각의 모듈에 맞는 기능을 수행할 수 있죠.





